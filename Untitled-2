public Bitmap rotateImage(){ 
    if(mBitmap == null) return null; 
    //Save image before rotate 
    
    int width = mBitmap.getWidth(); 
    int height = mBitmap.getHeight();  

    float radian = 0;//degrees * M_PI / 180; 
    int offset_x = 0;//(width-height)/2 * (1 - cos(radian)); 
    int offset_y = 0;//(width-height)/2 * -sin(radian); 
    //radian = -radian; //回転方法を反転 
    float mDegreeTemp=0.0f; 
    switch (mRotateState){ 
        case 0: { 
            radian = (float)( -mDegrees * PI / 180); 
            break; 
        } 
        case 90: { 
            radian = (float)((-90 - mDegrees) * PI / 180); 
            break; 
        } 
        case 180: { 
            radian = (float)((180.0 - mDegrees) * PI / 180); 
            break; 
        } 
        case 270: { 
            radian = (float)((90.0 - mDegrees) * PI / 180); 
            break; 
        } 
        default: { 
            radian = (float)( -mDegrees * PI / 180); 
            break; 
        } 
    } 
    offset_x =(int) ((width-height)/2 * (1 - Math.cos(radian))); 
    offset_y = (int)((width-height)/2 * -Math.sin(radian)); 
    int position_x = -width/2 + offset_x; 
    int position_y = -height/2 - offset_y;  

    Matrix matrix = new Matrix(); 
    float degree = (float) Math.toDegrees(radian); 
    Logger.d(this, "rotateImage", " mRotateState: " + mRotateState + " mDegrees: " + mDegrees + " image rotate: " + degree );

    matrix.postRotate(degree,width/2,height/2);  

    Bitmap rotatedBitmap = Bitmap.createBitmap(mBitmap, 0,0, 
            width, height, matrix, true);  

    Bitmap target = Bitmap.createBitmap(width, height, mBitmap.getConfig()); 
    Canvas canvas = new Canvas(target); 
    canvas.save(); 
    canvas.drawBitmap(rotatedBitmap,0,0,null); 
    canvas.restore(); 
        
    return target;  

}